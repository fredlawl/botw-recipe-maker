import * as fs from 'fs';
import {Logic, recipeConfiguration, RecipeIngredient} from "./recipeConfiguration"
import {categoryToMaterialsLookupTable, MaterialType, materialTypeLookupTable} from "./materials";
import {ItemStack} from "../ItemStack";
import {Material} from "../Material";
import {Recipe} from "../Recipe";
import {exit} from 'process';
import {EntityType} from "../../Entity";
import {Category, primaryCategories} from "./itemCategories";

/**
 * Creates a forest of the logic operations performed for the given recipe
 * configuration. Later algorithm for all the combinations will use the
 * order provided by this function.
 *
 * @param recipeLogic
 */
const createForests = (recipeLogic: any[]): any[] => {
	const ingredients: RecipeIngredient[] = recipeLogic.slice(1, recipeLogic.length);
	let forest: any[] = [];

	for (let i = 0, len = ingredients.length; i < len; i++) {
		if (Array.isArray(ingredients[i])) {
			forest = [...forest, ...createForests(ingredients[i] as any)];
			recipeLogic.splice(i + 1, 1);
			ingredients.splice(i, 1);
			i--;
			len--;
		}
	}

	if (recipeLogic.length > 1) {
		forest.push(recipeLogic);
	}

	return forest;
};

/**
 * Calculates the total number of combinations for the given recipe logic.
 * @param recipeLogic
 */
const calculateTotalCombinations = (recipeLogic: any[]): number => {
	const [logicOp, ...ingredients] = recipeLogic;
	let combinations = 1;

	// Do all nested logic first
	for (const ingredient of ingredients) {
		if (!Array.isArray(ingredient))
			continue;

		combinations *= calculateTotalCombinations(ingredient);
	}

	if (logicOp === Logic.OR) {
		combinations *= ingredients.length;
	}

	return combinations;
};

/**
 * Given a recipe configuration this will expand categories out to their
 * respective materials.
 * @param recipeLogic
 */
const convertCategoriesToNestedORLogic = (recipeLogic: any[]): void => {
	const ingredients: RecipeIngredient[] = recipeLogic.slice(1, recipeLogic.length);
	for (const [i, ingredient] of ingredients.entries()) {
		if (Array.isArray(ingredient)) {
			convertCategoriesToNestedORLogic(ingredient);
			continue;
		}

		if (!ingredient.entity.isType(EntityType.Category))
			continue;

		const ingredientsFromCategory = Array.from(categoryToMaterialsLookupTable[ingredient.entity.id]).map((materialId) => {
			return new RecipeIngredient(materialTypeLookupTable[materialId as number], ingredient.amount);
		});

		// Need the plus one due to the slicing above
		recipeLogic[i + 1] = [
			Logic.OR,
			...ingredientsFromCategory
		];
	}
};

/**
 *
 * @param material
 */
const writeMaterialLookup = (material: Material) => {
	return `allMaterials[materialIdToMaterialLookupTable['${material.id}']]`;
};

/**
 *
 * @param arr
 * @param fn
 */
const writeArray = <T>(arr: T[], fn: (item: T) => string) => {
	return `[${arr.map(i => fn(i)).join(',')}]`;
};

/**
 *
 * @param recipe
 */
const writeRecipe = (recipe: Recipe): string => {
	return `new Recipe('${recipe.name}', ${writeArray(recipe.ingredients, (ri) => {
		return `new ItemStack<Material>(${writeMaterialLookup(ri.item)}, ${ri.stack})`
	})}),\n`;
};

/*
	We're going to open a write stream to begin writing to the recipes.ts
	file. This is where we're going to write all of our data from this
	compiler to.
 */
const recipesFilePath = './src/item/database/recipes.ts';
const writeStream = fs.createWriteStream(recipesFilePath, {
	flags: "w+"
});

if (!writeStream) {
	console.error(`Could not open file "${recipesFilePath}"`);
	exit();
}

try {
	/*
		Setup the file for writing
	 */
	writeStream.write(
`
/*
	WARNING: THIS FILE IS GENERATED BY THE compile-recipes SCRIPT. DO NOT EDIT!
 */

import {ItemStack} from "../ItemStack";
import {Material} from "../Material";
import {Recipe} from "../Recipe";
import {allMaterials, materialIdToMaterialLookupTable} from "./materials";\n

export const recipes: Recipe[] = [
`);

	const config = recipeConfiguration;
	// const config = [
	// 	{
	// 		name: "Roasted Trout x2",
	// 		logic: [
	// 			Logic.AND,
	// 			[
	// 				Logic.OR,
	// 				new RecipeIngredient(materialTypeLookupTable[MaterialType.CHILLFIN_TROUT], 1),
	// 				new RecipeIngredient(materialTypeLookupTable[MaterialType.SIZZLEFIN_TROUT], 1),
	// 				new RecipeIngredient(materialTypeLookupTable[MaterialType.ACORN], 1)
	// 			],
	// 			[
	// 				Logic.OR,
	// 				new RecipeIngredient(materialTypeLookupTable[MaterialType.STEALTHFIN_TROUT], 1),
	// 				new RecipeIngredient(materialTypeLookupTable[MaterialType.VOLTFIN_TROUT], 1),
	// 			]
	// 		]
	// 	},
	// 	{
	// 		name: "Roasted Trout",
	// 		logic: [
	// 			Logic.OR,
	// 			new RecipeIngredient(materialTypeLookupTable[MaterialType.CHILLFIN_TROUT], 1),
	// 			new RecipeIngredient(materialTypeLookupTable[MaterialType.SIZZLEFIN_TROUT], 1),
	// 			new RecipeIngredient(materialTypeLookupTable[MaterialType.STEALTHFIN_TROUT], 1),
	// 			new RecipeIngredient(materialTypeLookupTable[MaterialType.VOLTFIN_TROUT], 1),
	// 		]
	// 	},
	// 	{
	// 		name: "Fruitcake",
	// 		logic: [
	// 			Logic.AND,
	// 			new RecipeIngredient(materialTypeLookupTable[MaterialType.TABANTHA_WHEAT], 1),
	// 			new RecipeIngredient(materialTypeLookupTable[MaterialType.CANE_SUGAR], 1),
	// 			new RecipeIngredient(primaryCategories[Category.FRUIT], 1),
	// 			[
	// 				Logic.OR,
	// 				new RecipeIngredient(materialTypeLookupTable[MaterialType.APPLE], 1),
	// 				new RecipeIngredient(materialTypeLookupTable[MaterialType.WILDBERRY], 1),
	// 			]
	// 		]
	// 	}
	// ];

	for (const recipeConfig of config) {
		convertCategoriesToNestedORLogic(recipeConfig.logic);
		const numberOfIterations = calculateTotalCombinations(recipeConfig.logic);
		const forests = createForests(recipeConfig.logic);
		let requiredIngredients: ItemStack<Material>[] = [];
		let combinationals: any[] = [];

		/*
			This is a little extra, but this _could_ happen, so we have
			the ID generation for a recipe sort the ingredients alphabetically
			and with numbers to ensure uniqueness on the ID.

			Slows down slightly, but has storage potential & fixes
			reacts unique ID problem for lists.
		 */
		const uniqueRecipes: Map<string, Recipe> = new Map<string, Recipe>();

		for (const tree of forests) {
			const [logicOp, ...ingredients] = tree;
			if (logicOp === Logic.OR) {
				combinationals.push(ingredients);
				continue;
			}

			requiredIngredients = [...requiredIngredients, ...ingredients.map((ri: RecipeIngredient) => {
				return new ItemStack<Material>(ri.entity as Material, ri.amount);
			})];
		}

		// Need to copy the two dimensional array to repopulate the stacks
		const combinationalCopies = combinationals.map(c => [...c]);

		for (let i = 0; i < numberOfIterations; i++) {
			const materials: Map<string, ItemStack<Material>> = new Map<string, ItemStack<Material>>(
				requiredIngredients.map(ri => {
					return [ri.item.id, ri];
				})
			);

			for (let [i, ingredients] of combinationals.entries()) {
				let ingredient = ingredients.pop();

				if (!ingredient) {
					ingredients.push.apply(ingredients, [...combinationalCopies[i]]);
					ingredient = ingredients.pop();
				}

				/*
					We count the ingredients that are the same for this
					variation of the recipe to apply.
				 */
				const itemStack = new ItemStack<Material>(ingredient.entity as Material, ingredient.amount);
				const foundItemStack = materials.get(itemStack.item.id);
				if (foundItemStack) {
					materials.set(itemStack.item.id, foundItemStack.increment(1));
					continue;
				}

				materials.set(itemStack.item.id, itemStack);
			}

			const recipe = new Recipe(recipeConfig.name, Array.from(materials.values()));
			uniqueRecipes.set(recipe.id, recipe);
		}

		for (const recipe of uniqueRecipes.values()) {
			writeStream.write(writeRecipe(recipe));
		}
	}

	writeStream.write('];\n\n');

} catch (err) {
	console.error('Some error occurred during processing: ', err);
} finally {
	writeStream.close();
}
