import * as fs from 'fs';
import {Logic, recipeConfiguration, RecipeIngredient} from "./recipeConfiguration"
import {categoryToMaterialsLookupTable, MaterialType, materialTypeLookupTable} from "./materials";
import {ItemStack} from "../ItemStack";
import {Material} from "../Material";
import {Recipe} from "../Recipe";
import {exit} from 'process';
import {EntityType} from "../../Entity";
import {Category, primaryCategories} from "./itemCategories";

/**
 * Creates a forest of the logic operations performed for the given recipe
 * configuration. Later algorithm for all the combinations will use the
 * order provided by this function.
 *
 * @param recipeLogic
 */
const createForests = (recipeLogic: any[]): any[] => {

	const forests = (recipeLogic: any[]) => {
		const ingredients: RecipeIngredient[] = recipeLogic.slice(1, recipeLogic.length);
		let forest: any[] = [];

		for (let i = 0, len = ingredients.length; i < len; i++) {
			if (Array.isArray(ingredients[i])) {
				forest = [...forest, ...createForests(ingredients[i] as any)];
				recipeLogic.splice(i + 1, 1);
				ingredients.splice(i, 1);
				i--;
				len--;
			}
		}

		if (recipeLogic.length > 1) {
			forest.push(recipeLogic);
		}

		return forest;
	};

	// Sort by Logic, if both are OR, then shortest OR length first
	return forests(recipeLogic).sort((a: any[], b: any[]) => {
		const [aLogicOp, ...aIngredients] = a;
		const [bLogicOp, ...bIngredients] = b;
		if (aLogicOp === Logic.AND && aLogicOp === bLogicOp) {
			return 0;
		}

		if (aLogicOp === Logic.OR && aLogicOp === bLogicOp) {
			return aIngredients.length > bIngredients.length ? 1 :  -1;
		}

		return (aLogicOp === Logic.AND && aLogicOp !== bLogicOp) ? 1 : -1;
	});
};

/**
 * Calculates the total number of combinations for the given recipe logic.
 * @param recipeLogic
 */
const calculateTotalCombinations = (recipeLogic: any[]): number => {
	const [logicOp, ...ingredients] = recipeLogic;
	let combinations = 1;

	// Do all nested logic first
	for (const ingredient of ingredients) {
		if (!Array.isArray(ingredient))
			continue;

		combinations *= calculateTotalCombinations(ingredient);
	}

	if (logicOp === Logic.OR) {
		combinations *= ingredients.length;
	}

	return combinations;
};

/**
 * Given a recipe configuration this will expand categories out to their
 * respective materials.
 * @param recipeLogic
 */
const convertCategoriesToNestedORLogic = (recipeLogic: any[]): void => {
	const ingredients: RecipeIngredient[] = recipeLogic.slice(1, recipeLogic.length);
	for (const [i, ingredient] of ingredients.entries()) {
		if (Array.isArray(ingredient)) {
			convertCategoriesToNestedORLogic(ingredient);
			continue;
		}

		if (!ingredient.entity.isType(EntityType.Category))
			continue;

		const ingredientsFromCategory = Array.from(categoryToMaterialsLookupTable[ingredient.entity.id]).map((materialId) => {
			return new RecipeIngredient(materialTypeLookupTable[materialId as number], ingredient.amount);
		});

		// Need the plus one due to the slicing above
		recipeLogic[i + 1] = [
			Logic.OR,
			...ingredientsFromCategory
		];
	}
};

/**
 *
 * @param material
 */
const writeMaterialLookup = (material: Material) => {
	return `allMaterials[materialIdToMaterialLookupTable['${material.id}']]`;
};

/**
 *
 * @param arr
 * @param fn
 */
const writeArray = <T>(arr: T[], fn: (item: T) => string) => {
	return `[${arr.map(i => fn(i)).join(',')}]`;
};

/**
 *
 * @param recipe
 */
const writeRecipe = (recipe: Recipe): string => {
	return `new Recipe('${recipe.name}', ${writeArray(recipe.ingredients, (ri) => {
		return `new ItemStack<Material>(${writeMaterialLookup(ri.item)}, ${ri.stack})`
	})}),\n`;
};

/*
	We're going to open a write stream to begin writing to the recipes.ts
	file. This is where we're going to write all of our data from this
	compiler to.
 */
const recipesFilePath = './src/item/database/recipes.ts';
const writeStream = fs.createWriteStream(recipesFilePath, {
	flags: "w+"
});

if (!writeStream) {
	console.error(`Could not open file "${recipesFilePath}"`);
	exit();
}

try {
	/*
		Setup the file for writing
	 */
	writeStream.write(
`
/*
	WARNING: THIS FILE IS GENERATED BY THE compile-recipes SCRIPT. DO NOT EDIT!
 */

import {ItemStack} from "../ItemStack";
import {Material} from "../Material";
import {Recipe} from "../Recipe";
import {allMaterials, materialIdToMaterialLookupTable} from "./materials";\n

export const recipes: Recipe[] = [
`);

	const config = recipeConfiguration;
	// const config = [
	// 	{
	// 		name: "Roasted Trout x2",
	// 		logic: [
	// 			Logic.AND,
	// 			[
	// 				Logic.OR,
	// 				new RecipeIngredient(materialTypeLookupTable[MaterialType.CHILLFIN_TROUT], 1),
	// 				new RecipeIngredient(materialTypeLookupTable[MaterialType.SIZZLEFIN_TROUT], 1),
	// 				new RecipeIngredient(materialTypeLookupTable[MaterialType.ACORN], 1)
	// 			],
	// 			[
	// 				Logic.OR,
	// 				new RecipeIngredient(materialTypeLookupTable[MaterialType.STEALTHFIN_TROUT], 1),
	// 				new RecipeIngredient(materialTypeLookupTable[MaterialType.VOLTFIN_TROUT], 1),
	// 			]
	// 		]
	// 	},
	// 	{
	// 		name: "Roasted Trout",
	// 		logic: [
	// 			Logic.OR,
	// 			new RecipeIngredient(materialTypeLookupTable[MaterialType.CHILLFIN_TROUT], 1),
	// 			new RecipeIngredient(materialTypeLookupTable[MaterialType.SIZZLEFIN_TROUT], 1),
	// 			new RecipeIngredient(materialTypeLookupTable[MaterialType.STEALTHFIN_TROUT], 1),
	// 			new RecipeIngredient(materialTypeLookupTable[MaterialType.VOLTFIN_TROUT], 1),
	// 		]
	// 	},
	// 	{
	// 		name: "Fruitcake",
	// 		logic: [
	// 			Logic.AND,
	// 			new RecipeIngredient(materialTypeLookupTable[MaterialType.TABANTHA_WHEAT], 1),
	// 			new RecipeIngredient(materialTypeLookupTable[MaterialType.CANE_SUGAR], 1),
	// 			new RecipeIngredient(primaryCategories[Category.FRUIT], 1),
	// 			[
	// 				Logic.OR,
	// 				new RecipeIngredient(materialTypeLookupTable[MaterialType.APPLE], 1),
	// 				new RecipeIngredient(materialTypeLookupTable[MaterialType.WILDBERRY], 1),
	// 			]
	// 		]
	// 	}
	// ];

	for (const recipeConfig of config) {
		convertCategoriesToNestedORLogic(recipeConfig.logic);
		const numberOfIterations = calculateTotalCombinations(recipeConfig.logic);
		const forests = createForests(recipeConfig.logic);
		let requiredIngredients: ItemStack<Material>[] = [];
		let combinationals: any[] = [];
		const recipes: Recipe[] = [];

		for (const tree of forests) {
			const [logicOp, ...ingredients] = tree;
			if (logicOp === Logic.OR) {
				combinationals.push(ingredients);
				continue;
			}

			requiredIngredients = [...requiredIngredients, ...ingredients.map((ri: RecipeIngredient) => {
				return new ItemStack<Material>(ri.entity as Material, ri.amount);
			})];
		}

		// Need to copy the two dimensional array to repopulate the stacks
		const combinationalCopies = combinationals.map(c => [...c]);

		for (let i = 0; i < numberOfIterations; i++) {
			const materials: ItemStack<Material>[] = [];
			for (let [i, ingredients] of combinationals.entries()) {
				let ingredient = ingredients.pop();

				if (!ingredient) {
					ingredients.push.apply(ingredients, [...combinationalCopies[i]]);
					ingredient = ingredients.pop();
				}

				materials.push(new ItemStack<Material>(ingredient.entity as Material, ingredient.amount));
			}

			recipes.push(new Recipe(recipeConfig.name, [...requiredIngredients, ...materials]));
		}

		// Now that we have all the recipes, we perform a final combine on ingredients that may have doubled up
		// TODO: This helps the counting check on the matching process

		// Finally write out the recipes
		for (const recipe of recipes) {
			writeStream.write(writeRecipe(recipe));
		}
	}

	writeStream.write('];\n\n');

} catch (err) {
	console.error('Some error occurred during processing: ', err);
} finally {
	writeStream.close();
}
